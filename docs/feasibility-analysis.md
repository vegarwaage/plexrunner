# Building a Plex App for Garmin Forerunner 970: Feasibility Analysis

**The Garmin Forerunner 970 exists and the project is technically feasible, but you'll need to adopt an offline-first architecture.** The watch's Connect IQ platform cannot stream audio in real-time—instead, your app must download content from Plex servers for offline playback, similar to how Spotify and Amazon Music work on Garmin devices. Claude Code can accelerate development but won't replace the need for Garmin-specific expertise.

This represents a significant departure from typical Plex client behavior. Rather than streaming on-demand, users would select playlists, albums, or audiobooks to sync to their watch over WiFi, then play that cached content during workouts. The technical building blocks exist across all three platforms—Plex's API, Garmin's Connect IQ SDK, and Claude Code's development assistance—but assembling them requires understanding substantial platform constraints.

## The Forerunner 970 is real and capable

Garmin released the Forerunner 970 in May 2025 as their flagship running and triathlon smartwatch at $749.99. The model number is correct—this isn't a typo or confusion with the earlier Forerunner 965. The hardware provides everything needed for audio playback: **32 GB internal storage** (enough for approximately 500 audio files), comprehensive format support including MP3, M4A, AAC, and WAV, and Bluetooth connectivity for wireless headphones. Battery life delivers 12 hours when using GPS tracking with music playback simultaneously.

The device includes a built-in speaker and microphone, though reviews consistently note the speaker has "subpar audio volume" and isn't suitable for quality music listening in public spaces. Bluetooth headphones are the recommended playback method. The watch runs Garmin's proprietary operating system with the Connect IQ 8.0+ platform for third-party apps, supports up to 32 installed applications, and handles independent music playback without requiring a paired smartphone nearby.

The processor specifications remain undisclosed by Garmin, but reviews indicate it's "optimized to handle all on-watch tasks fairly quickly, though slower than a smartwatch with proper RAM." The system prioritizes battery efficiency over raw performance and struggles somewhat with intensive tasks like offline map operations. For audio playback and file management, however, the hardware is proven—major music services already operate successfully on this platform.

## Connect IQ requires a download-first architecture

Here's the critical constraint that will shape your entire development approach: **Garmin Connect IQ audio apps cannot stream in real-time.** This isn't a missing feature you can work around—it's a fundamental architectural decision in how Garmin designed the platform for battery efficiency and offline-first wearable use.

Audio Content Provider Apps represent a special application type in Connect IQ. They download audio files via HTTP requests using `Communications.makeWebRequest()`, store them in encrypted format on the device, and provide that content to Garmin's native media player. Your app handles authentication, content selection, download management, and metadata—but the actual playback happens entirely in Garmin's built-in player. You cannot write custom playback code, control audio output directly, or stream content during playback.

The successful precedent exists. **Spotify, Amazon Music, Deezer, and YouTube Music** all operate with this architecture on Garmin watches. Users open the app in "sync mode," select playlists or albums to download over WiFi (or slowly over Bluetooth via their phone), wait for the download to complete, then access that content through the native music player during activities. When the user hits play in the media player, the system decrypts your cached audio and plays it. Your app receives playback events through callback methods but doesn't control the playback itself.

The technical implementation uses Monkey C, Garmin's proprietary object-oriented language influenced by JavaScript, Java, and Python but specifically designed for low-power wearables. The syntax is accessible but the ecosystem is small—developers describe it as easier for beginners but frustrating for experienced programmers due to limited capabilities. You'll work with classes like `AudioContentProviderApp` (base class), `Media.ContentDelegate` (handles playback callbacks), `Media.ContentIterator` (provides track lists), and `Media.Content` (represents individual audio files). Memory constraints vary by device but typically range from 28-92 KB for app code, with approximately 100 KB available for persistent storage using the `Application.Storage` API.

Network capabilities are robust. The platform supports full HTTP requests with GET, POST, PUT, and DELETE methods, custom headers, and OAuth 2.0 authentication flows. Apps can trigger phone notifications that open web views for user login, receive tokens via callbacks, and store them securely in persistent storage. This matches exactly what Plex requires.

## Plex provides everything your app needs

Plex formally released official API documentation in January 2025 during "Plex Pro Week '25: API Unlocked," though the community has maintained comprehensive unofficial documentation for years. The API is RESTful, returns XML by default (JSON available with appropriate headers), and provides complete access to music libraries, podcast collections, and audiobook content.

Authentication uses a modern PIN-based OAuth flow perfect for wearables. Your app generates a unique client identifier, creates a time-limited PIN by calling `POST https://plex.tv/api/v2/pins`, directs the user to authenticate via `https://app.plex.tv/auth` with that PIN code, then polls the endpoint to retrieve an access token once the user approves. The token uses the `X-Plex-Token` header for all subsequent requests. Plex recently added JWT authentication with Ed25519 public-key cryptography for enhanced security, featuring 7-day token expiration and a three-step refresh process.

The audio capabilities are comprehensive. Library endpoints like `/library/sections` list all available libraries, `/library/sections/{id}/all` retrieves all items in a music library, and `/library/metadata/{ratingKey}` fetches specific track details. You get complete metadata including audio codecs, bitrates, duration, file sizes, album art, lyrics, play counts, and ratings. For streaming, the API supports Direct Play (original file without transcoding), Direct Stream (remuxing to compatible containers), and real-time Transcode to various bitrates and formats.

Most importantly for your use case, **Plex includes a comprehensive sync/download API** specifically designed for offline playback on mobile devices. This requires a Plex Pass subscription for the user and server owner permission to download, but it provides exactly what Connect IQ needs: the ability to download individual tracks, albums, artists, or playlists with configurable quality settings and automatic transcoding to device-compatible formats if needed. The Python-PlexAPI library demonstrates this with methods like `album.sync(bitrate=192, client=device)` and `track.download(savepath="/path")`.

Device registration requires specific headers that identify your app (`X-Plex-Client-Identifier`, `X-Plex-Product`, `X-Plex-Platform`, etc.) and declare capabilities via `X-Plex-Provides`. For offline download support, you'd register as a `sync-target` with `X-Plex-Sync-Version: 2`. The API has no documented rate limits for normal usage, supports HTTPS for secure transfers, and allows server owners to configure bandwidth caps and streaming quality restrictions.

No official Plex apps exist for any smartwatch platform. The only wearable integration found was "Android Wear Plex Remote" by TecSploit, a third-party remote control app with limited adoption. Community forums show repeated requests for native wearable music players, particularly for offline playback during fitness activities, but Plex hasn't addressed these requests or published a development roadmap for wearables. This represents both an opportunity (no official competition) and a challenge (no official support or guidance).

## Claude Code accelerates but doesn't replace expertise

Claude Code is Anthropic's dedicated agentic coding tool launched in 2025—a terminal-based development assistant that can also integrate with VS Code through a beta extension. It's not simply Claude's conversational coding abilities, but a specific product that maintains codebase awareness, directly manipulates files, executes terminal commands, handles Git operations, and works through autonomous workflows. The tool runs natively on macOS (along with Linux and Windows), requires Node.js 18+ or uses a standalone installer, and offers three deployment options: terminal CLI, VS Code extension, or web/mobile preview.

For mainstream languages, Claude Code excels. It has excellent support for Python, JavaScript, TypeScript, Java, C++, Go, Ruby, PHP, Swift, and their associated frameworks. It works with any development environment including VS Code (native extension), terminal-based editors like Vim, and IDEs through command-line integration. The tool can set up build systems, manage dependencies, write documentation, analyze logs, handle Git workflows, and autonomously implement features across multiple files.

**For Monkey C specifically, expect significantly limited effectiveness.** As a proprietary language with a small community, Monkey C has minimal training data in Claude Code's knowledge base. The tool will attempt to help and can extrapolate from its knowledge of similar languages like JavaScript and Java, but every code suggestion becomes an educated guess requiring manual verification. Claude explicitly performs worse with niche languages—it will generate syntactically plausible code that may contain Monkey C-specific errors, miss resource constraint patterns, or misuse device-specific APIs.

Where Claude Code will genuinely help: project structure and boilerplate generation, build script automation for the `monkeyc` compiler, creating and maintaining `monkey.jungle` configuration files, explaining existing Monkey C codebases, writing documentation and comments, Git commit management and PR creation, analyzing error logs, and translating general programming concepts into Monkey C syntax. It can assist with Connect IQ API integration by referencing documentation you provide, generate test scaffolds, and help with HTTP communication patterns for the Plex API calls.

What Claude Code cannot do: interact with the graphical `connectiq` simulator, run or test watch faces visually, validate appearance on different screen sizes, deploy builds to connected Garmin devices, guarantee Monkey C syntax correctness, understand device-specific hardware constraints without documentation, or handle real-time debugging with breakpoints. The tool operates in a sandboxed terminal environment and cannot manipulate GUI applications.

Rate limits present a practical concern. The Pro plan ($20/month) provides approximately 10-40 prompts per 5-hour rolling window, while the Max 20x plan ($200/month) extends this to 200-800 prompts with higher weekly caps. These limits are shared across all Claude Code usage (terminal, web, mobile) and can interrupt development mid-project. For heavy Connect IQ development, you'd need to plan intensive work around the 5-hour reset cycles or consider switching to API pay-as-you-go pricing for unlimited usage.

The realistic workflow positions Claude Code as an intelligent pair programmer requiring constant supervision. Use it for setup tasks, build automation, understanding patterns in example code, generating documentation, and speeding up boilerplate creation. Always verify generated Monkey C code against official Garmin documentation and test thoroughly in the simulator. Start with small, isolated functions to build a library of verified patterns, then expand to more complex features. Cross-reference suggestions with working Monkey C examples from GitHub repositories and the official connectiq-apps samples.

## Development workflow and timeline

Building this app requires a hybrid approach combining multiple tools and manual verification at each stage. Begin with environment setup: install the Connect IQ SDK 4.0.6+ via SDK Manager, configure Visual Studio Code with the official Monkey C extension, install Java Runtime 8+, generate your RSA 4096-bit developer key, and create a Garmin Developer Account. Claude Code can assist with automating these setup steps through terminal commands and documenting the configuration.

For the Plex integration, start by implementing PIN-based OAuth authentication in Monkey C. You'll call `Communications.makeOAuthRequest()` to trigger the phone notification flow, implement `registerForOAuthMessages()` to receive tokens, and use `Application.Storage` to securely persist the access token. Test this authentication flow thoroughly before proceeding. Claude Code can help structure this code and explain OAuth patterns, but you'll need to verify the Monkey C-specific syntax manually.

Build the content discovery interface next. Use Plex's `/library/sections` endpoint to retrieve the user's music libraries, then fetch playlists, albums, and tracks via `/library/sections/{id}/all`. Create a Connect IQ UI for browsing this content—users need to select what to download to their watch. This is the "sync configuration view" that Connect IQ requires. The interface must work on the Forerunner 970's 1.4-inch AMOLED display, so keep navigation simple with clear categories and search functionality.

The download implementation represents the core technical challenge. Use `Communications.makeWebRequest()` with `HTTP_RESPONSE_CONTENT_TYPE_AUDIO` to fetch audio files from Plex. You'll need to handle Plex's transcoding API to ensure the format is compatible (MP3 or M4A work best). The Garmin system automatically encrypts downloaded audio before storage. Implement progress tracking with `fileDownloadProgressCallback`, handle errors (network timeouts, storage full, authentication expiration), and report sync status via `notifySyncProgress()` and `notifySyncComplete()`.

Create your `ContentDelegate` implementation to respond to playback events. When users select your Plex provider in the native media player, Garmin calls your `getContentDelegate()` method. Return a `ContentIterator` that provides the list of downloaded tracks with metadata. Implement callbacks for `onSong()` (track played/skipped/paused), `onShuffle()`, `onRepeat()`, and any custom button actions. Use these callbacks to report playback statistics back to Plex if desired, updating play counts and last-played timestamps.

Testing requires the Connect IQ simulator for basic functionality verification, but you must test on an actual Forerunner 970 (or similar device like Fenix or Epix) for real audio playback, Bluetooth headphone connectivity, download speeds over WiFi, battery consumption during workouts with music, and the complete user experience. The simulator cannot accurately represent memory constraints, performance characteristics, or the actual audio pipeline. Plan to iterate multiple times based on physical device testing.

Memory optimization becomes critical. With 92 KB maximum for the app code (device-dependent) and 100 KB for persistent storage, every feature requires careful resource management. Keep the UI minimal, compress bitmaps aggressively, avoid loading all tracks into memory simultaneously, and use iterators efficiently. Test with hundreds of tracks to ensure the app doesn't exceed memory limits. Optimize for battery life by minimizing unnecessary background processing and network requests.

For deployment, build the release package (`.iq` file) using the `monkeyc` compiler with production settings, submit to the Connect IQ Store through your developer account, and prepare for Garmin's review process. Include clear documentation about Plex Pass requirements, setup instructions for OAuth authentication, and usage guidelines. Garmin reviews apps for security, user experience, and compliance with store guidelines—expect several days to weeks for approval.

A realistic timeline for a fully functional MVP: 2-3 months for an experienced developer working part-time, 4-8 weeks for full-time dedicated development. This assumes familiarity with API development and willingness to learn Monkey C. Add 2-4 weeks for comprehensive testing, bug fixes, and polish before store submission. A complete feature set matching Spotify's functionality (playlist management, download controls, playback reporting, album art, error handling) would extend this to 3-4 months of development.

## Alternative approaches and considerations

If the download-first constraint proves too limiting for your use case, consider a hybrid control approach. Build a companion smartphone app that runs a full Plex client and handles real-time streaming. The watch app becomes a remote control using Bluetooth communication to the phone app, providing playback controls, track selection, and status display while the phone handles the audio streaming and processing. This approach works when users carry their phones during activities but fails for phone-free workouts, one of the primary advantages of the Forerunner 970's standalone capabilities.

Another alternative involves pre-selecting content through Garmin Connect's web interface or mobile app. Users could manage their Plex downloads from a computer or phone, then the watch app simply retrieves the pre-configured download list and executes it. This reduces the complexity of building content browsing UI on the tiny watch screen while maintaining offline playback capability. The tradeoff is reduced flexibility—users can't spontaneously discover and download content directly from the watch.

For podcasts specifically, implement a "latest episodes" sync feature that automatically downloads new episodes from subscribed podcasts whenever the watch connects to WiFi. This mirrors how podcast apps work on phones and reduces manual management. Similarly, for audiobooks, implement chapter-by-chapter downloading to conserve storage space rather than forcing users to download entire books at once.

Consider the user experience carefully around storage management. With 32 GB total storage and a 500 audio file limit, users need visibility into how much space remains and tools to delete cached content. Implement a "smart sync" feature that automatically removes old or fully-listened content to make room for new downloads. Provide statistics via `Media.getCacheStatistics()` and batch deletion through `Media.deleteAllContent()` or selective deletion via `Media.deleteCachedItem()`.

The transcoding strategy significantly impacts download times and storage efficiency. Allow users to configure target bitrate (128 kbps, 192 kbps, 256 kbps) with estimates of how many songs fit at each quality level. Higher bitrates provide better audio quality but consume more storage and take longer to download. For WiFi sync, bandwidth isn't typically a constraint, but Bluetooth sync through the phone is extremely slow—set expectations appropriately and recommend WiFi for initial large syncs.

Authentication presents unique challenges on wearables. The PIN-based OAuth flow requires users to authenticate on their phone or computer, which adds friction but is necessary for security. Implement clear instructions in the app's first-run experience. Consider adding a "token refresh" notification system so users don't encounter unexpected authentication failures mid-workout. Store refresh tokens securely and implement automatic token renewal before expiration.

## Technical feasibility verdict: Possible but constrained

**You can build this app.** All three required components exist and can work together: the Forerunner 970 has sufficient hardware capabilities and storage, Garmin Connect IQ provides audio app APIs with proven implementations from major music services, Plex offers comprehensive APIs for authentication and audio content delivery, and Claude Code can accelerate development of the supporting infrastructure.

The critical constraint is architectural: you must accept the download-first, offline-playback model rather than real-time streaming. This fundamentally changes the user experience compared to typical Plex clients. Users plan ahead, select content to sync, wait for downloads to complete (potentially 5-20 minutes for an album over WiFi), then access that cached content during activities. This matches how existing Garmin music apps work—it's proven viable but requires user education and expectation management.

The development challenges are substantial but surmountable. Learning Monkey C takes time, especially with limited training data available for AI assistance tools. Memory optimization requires careful attention, testing on physical devices is mandatory, and the review/submission process adds delays. Claude Code helps with project scaffolding, build automation, API integration patterns, and documentation but cannot replace hands-on Garmin development expertise.

Budget 3-4 months for initial development with another month for testing and refinement. The effort is comparable to building a mobile app but with more constraints and less tooling support. If you have existing Plex server infrastructure and want to provide a differentiated experience for Garmin users, the project is viable. If you need real-time streaming or expect Claude Code to handle most implementation details autonomously, adjust expectations significantly.

The market opportunity is clear—no official Plex wearable app exists, and the Garmin ecosystem has millions of active users who regularly request better music and podcast integration. However, you're building for a niche within a niche: Plex users who own Garmin watches and are willing to accept a download-first workflow. Validate that audience size and their enthusiasm for the feature before committing substantial development resources.

Start with a minimal viable implementation: OAuth authentication, single playlist browsing, audio download, and basic playback integration with the native player. Get this working on physical hardware, gather user feedback, then incrementally add podcast support, audiobook integration, smart sync features, and advanced playlist management. The iterative approach mitigates risk while proving technical feasibility early in the development cycle.